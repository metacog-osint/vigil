-- Migration: Vulnerability-Asset Correlation
-- Created: 2026-01-16
-- Description: Track correlations between vulnerabilities and organizational assets

-- ============================================
-- ASSET VULNERABILITY CORRELATIONS
-- ============================================

-- Store vulnerability-to-asset matches
CREATE TABLE IF NOT EXISTS asset_vulnerability_correlations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  asset_id UUID NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
  vulnerability_id UUID NOT NULL REFERENCES vulnerabilities(id) ON DELETE CASCADE,
  correlation_score FLOAT NOT NULL DEFAULT 0,
  match_reasons JSONB DEFAULT '[]'::jsonb,
  status TEXT DEFAULT 'open' CHECK (status IN ('open', 'acknowledged', 'mitigated', 'accepted', 'false_positive')),
  mitigated_at TIMESTAMPTZ,
  mitigated_by UUID REFERENCES auth.users(id),
  mitigation_notes TEXT,
  discovered_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(asset_id, vulnerability_id)
);

-- ============================================
-- ASSET EXPOSURE FIELDS
-- ============================================

-- Add exposure tracking fields to assets
ALTER TABLE assets ADD COLUMN IF NOT EXISTS exposure_score INTEGER DEFAULT 0;
ALTER TABLE assets ADD COLUMN IF NOT EXISTS vulnerability_count INTEGER DEFAULT 0;
ALTER TABLE assets ADD COLUMN IF NOT EXISTS critical_vuln_count INTEGER DEFAULT 0;
ALTER TABLE assets ADD COLUMN IF NOT EXISTS high_vuln_count INTEGER DEFAULT 0;
ALTER TABLE assets ADD COLUMN IF NOT EXISTS last_vuln_scan TIMESTAMPTZ;
ALTER TABLE assets ADD COLUMN IF NOT EXISTS exposure_level TEXT GENERATED ALWAYS AS (
  CASE
    WHEN exposure_score >= 80 THEN 'critical'
    WHEN exposure_score >= 50 THEN 'high'
    WHEN exposure_score >= 20 THEN 'medium'
    WHEN exposure_score > 0 THEN 'low'
    ELSE 'none'
  END
) STORED;

-- ============================================
-- EXPOSURE HISTORY
-- ============================================

-- Track exposure score changes over time
CREATE TABLE IF NOT EXISTS asset_exposure_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  asset_id UUID NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
  exposure_score INTEGER NOT NULL,
  vulnerability_count INTEGER NOT NULL DEFAULT 0,
  critical_count INTEGER DEFAULT 0,
  high_count INTEGER DEFAULT 0,
  medium_count INTEGER DEFAULT 0,
  low_count INTEGER DEFAULT 0,
  recorded_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- FUNCTIONS
-- ============================================

-- Calculate exposure score for an asset
CREATE OR REPLACE FUNCTION calculate_asset_exposure(p_asset_id UUID)
RETURNS INTEGER AS $$
DECLARE
  v_score INTEGER := 0;
  v_critical INTEGER;
  v_high INTEGER;
  v_medium INTEGER;
  v_low INTEGER;
  v_kev INTEGER;
  v_exploitable INTEGER;
BEGIN
  -- Count vulnerabilities by severity
  SELECT
    COUNT(*) FILTER (WHERE v.severity = 'CRITICAL'),
    COUNT(*) FILTER (WHERE v.severity = 'HIGH'),
    COUNT(*) FILTER (WHERE v.severity = 'MEDIUM'),
    COUNT(*) FILTER (WHERE v.severity = 'LOW'),
    COUNT(*) FILTER (WHERE v.is_kev = true),
    COUNT(*) FILTER (WHERE v.has_public_exploit = true)
  INTO v_critical, v_high, v_medium, v_low, v_kev, v_exploitable
  FROM asset_vulnerability_correlations avc
  JOIN vulnerabilities v ON v.id = avc.vulnerability_id
  WHERE avc.asset_id = p_asset_id
    AND avc.status NOT IN ('mitigated', 'false_positive');

  -- Calculate weighted score
  v_score := (v_critical * 40) + (v_high * 25) + (v_medium * 10) + (v_low * 3);
  v_score := v_score + (v_kev * 30) + (v_exploitable * 20);

  -- Cap at 100
  RETURN LEAST(100, v_score);
END;
$$ LANGUAGE plpgsql;

-- Update asset exposure after correlation changes
CREATE OR REPLACE FUNCTION update_asset_exposure()
RETURNS TRIGGER AS $$
BEGIN
  -- Update the asset's exposure score
  UPDATE assets
  SET
    exposure_score = calculate_asset_exposure(COALESCE(NEW.asset_id, OLD.asset_id)),
    vulnerability_count = (
      SELECT COUNT(*) FROM asset_vulnerability_correlations
      WHERE asset_id = COALESCE(NEW.asset_id, OLD.asset_id)
        AND status NOT IN ('mitigated', 'false_positive')
    ),
    critical_vuln_count = (
      SELECT COUNT(*) FROM asset_vulnerability_correlations avc
      JOIN vulnerabilities v ON v.id = avc.vulnerability_id
      WHERE avc.asset_id = COALESCE(NEW.asset_id, OLD.asset_id)
        AND avc.status NOT IN ('mitigated', 'false_positive')
        AND v.severity = 'CRITICAL'
    ),
    high_vuln_count = (
      SELECT COUNT(*) FROM asset_vulnerability_correlations avc
      JOIN vulnerabilities v ON v.id = avc.vulnerability_id
      WHERE avc.asset_id = COALESCE(NEW.asset_id, OLD.asset_id)
        AND avc.status NOT IN ('mitigated', 'false_positive')
        AND v.severity = 'HIGH'
    ),
    updated_at = NOW()
  WHERE id = COALESCE(NEW.asset_id, OLD.asset_id);

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Trigger to update exposure on correlation changes
DROP TRIGGER IF EXISTS update_asset_exposure_trigger ON asset_vulnerability_correlations;
CREATE TRIGGER update_asset_exposure_trigger
  AFTER INSERT OR UPDATE OR DELETE ON asset_vulnerability_correlations
  FOR EACH ROW
  EXECUTE FUNCTION update_asset_exposure();

-- Record exposure history (for trending)
CREATE OR REPLACE FUNCTION record_exposure_snapshot()
RETURNS void AS $$
BEGIN
  INSERT INTO asset_exposure_history (
    asset_id,
    exposure_score,
    vulnerability_count,
    critical_count,
    high_count,
    medium_count,
    low_count
  )
  SELECT
    a.id,
    a.exposure_score,
    a.vulnerability_count,
    a.critical_vuln_count,
    a.high_vuln_count,
    COALESCE((
      SELECT COUNT(*) FROM asset_vulnerability_correlations avc
      JOIN vulnerabilities v ON v.id = avc.vulnerability_id
      WHERE avc.asset_id = a.id AND v.severity = 'MEDIUM'
        AND avc.status NOT IN ('mitigated', 'false_positive')
    ), 0),
    COALESCE((
      SELECT COUNT(*) FROM asset_vulnerability_correlations avc
      JOIN vulnerabilities v ON v.id = avc.vulnerability_id
      WHERE avc.asset_id = a.id AND v.severity = 'LOW'
        AND avc.status NOT IN ('mitigated', 'false_positive')
    ), 0)
  FROM assets a
  WHERE a.status = 'active';
END;
$$ LANGUAGE plpgsql;

-- Get assets sorted by exposure
CREATE OR REPLACE FUNCTION get_exposed_assets(p_team_id UUID DEFAULT NULL, p_limit INTEGER DEFAULT 20)
RETURNS TABLE(
  asset_id UUID,
  asset_name TEXT,
  asset_type TEXT,
  exposure_score INTEGER,
  exposure_level TEXT,
  vulnerability_count INTEGER,
  critical_count INTEGER,
  high_count INTEGER,
  kev_count BIGINT,
  exploitable_count BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    a.id AS asset_id,
    a.name AS asset_name,
    a.asset_type,
    a.exposure_score,
    a.exposure_level,
    a.vulnerability_count,
    a.critical_vuln_count AS critical_count,
    a.high_vuln_count AS high_count,
    (SELECT COUNT(*) FROM asset_vulnerability_correlations avc
     JOIN vulnerabilities v ON v.id = avc.vulnerability_id
     WHERE avc.asset_id = a.id AND v.is_kev = true
       AND avc.status NOT IN ('mitigated', 'false_positive')) AS kev_count,
    (SELECT COUNT(*) FROM asset_vulnerability_correlations avc
     JOIN vulnerabilities v ON v.id = avc.vulnerability_id
     WHERE avc.asset_id = a.id AND v.has_public_exploit = true
       AND avc.status NOT IN ('mitigated', 'false_positive')) AS exploitable_count
  FROM assets a
  WHERE (p_team_id IS NULL OR a.team_id = p_team_id)
    AND a.status = 'active'
    AND a.exposure_score > 0
  ORDER BY a.exposure_score DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- INDEXES
-- ============================================

CREATE INDEX IF NOT EXISTS idx_avc_asset ON asset_vulnerability_correlations(asset_id);
CREATE INDEX IF NOT EXISTS idx_avc_vulnerability ON asset_vulnerability_correlations(vulnerability_id);
CREATE INDEX IF NOT EXISTS idx_avc_status ON asset_vulnerability_correlations(status);
CREATE INDEX IF NOT EXISTS idx_avc_score ON asset_vulnerability_correlations(correlation_score DESC);
CREATE INDEX IF NOT EXISTS idx_assets_exposure ON assets(exposure_score DESC) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_exposure_history_asset ON asset_exposure_history(asset_id);
CREATE INDEX IF NOT EXISTS idx_exposure_history_time ON asset_exposure_history(recorded_at);

-- ============================================
-- RLS POLICIES
-- ============================================

ALTER TABLE asset_vulnerability_correlations ENABLE ROW LEVEL SECURITY;
ALTER TABLE asset_exposure_history ENABLE ROW LEVEL SECURITY;

-- Correlations inherit access from assets
CREATE POLICY "Users can view correlations for their assets" ON asset_vulnerability_correlations
  FOR SELECT USING (
    asset_id IN (
      SELECT id FROM assets WHERE user_id = auth.uid()
      UNION
      SELECT id FROM assets WHERE team_id IN (SELECT team_id FROM team_members WHERE user_id = auth.uid())
    )
  );

CREATE POLICY "Users can manage correlations for their assets" ON asset_vulnerability_correlations
  FOR ALL USING (
    asset_id IN (
      SELECT id FROM assets WHERE user_id = auth.uid()
      UNION
      SELECT id FROM assets WHERE team_id IN (SELECT team_id FROM team_members WHERE user_id = auth.uid())
    )
  );

CREATE POLICY "Users can view exposure history for their assets" ON asset_exposure_history
  FOR SELECT USING (
    asset_id IN (
      SELECT id FROM assets WHERE user_id = auth.uid()
      UNION
      SELECT id FROM assets WHERE team_id IN (SELECT team_id FROM team_members WHERE user_id = auth.uid())
    )
  );
