-- Migration 039: Add exploit maturity tracking to vulnerabilities
-- Tracks the maturity level of exploits for better prioritization

-- Create exploit maturity enum
DO $$ BEGIN
  CREATE TYPE exploit_maturity AS ENUM (
    'not_defined',      -- No exploit information available
    'unproven',         -- Unproven exploit exists (theoretical)
    'poc',              -- Proof of concept code available
    'functional',       -- Functional exploit exists
    'high',             -- High maturity - reliable exploit in the wild
    'weaponized'        -- Weaponized - actively used in attacks
  );
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- Add exploit maturity columns to vulnerabilities
ALTER TABLE vulnerabilities
ADD COLUMN IF NOT EXISTS exploit_maturity exploit_maturity DEFAULT 'not_defined',
ADD COLUMN IF NOT EXISTS exploit_maturity_source TEXT,
ADD COLUMN IF NOT EXISTS exploit_maturity_updated_at TIMESTAMPTZ;

-- Add exploit details JSONB for rich exploit information
ALTER TABLE vulnerabilities
ADD COLUMN IF NOT EXISTS exploit_details JSONB DEFAULT '{}';

-- Comment on columns
COMMENT ON COLUMN vulnerabilities.exploit_maturity IS 'Maturity level of known exploits for this vulnerability';
COMMENT ON COLUMN vulnerabilities.exploit_maturity_source IS 'Source of exploit maturity information (e.g., exploit-db, nuclei, manual)';
COMMENT ON COLUMN vulnerabilities.exploit_maturity_updated_at IS 'When exploit maturity was last updated';
COMMENT ON COLUMN vulnerabilities.exploit_details IS 'Detailed exploit information including URLs, types, platforms';

-- Create index for exploit maturity queries
CREATE INDEX IF NOT EXISTS idx_vulnerabilities_exploit_maturity
ON vulnerabilities(exploit_maturity)
WHERE exploit_maturity != 'not_defined';

-- Create index for high-priority exploited vulns
CREATE INDEX IF NOT EXISTS idx_vulnerabilities_weaponized
ON vulnerabilities(cvss_score DESC)
WHERE exploit_maturity IN ('high', 'weaponized');

-- Function to update exploit maturity based on various sources
CREATE OR REPLACE FUNCTION update_exploit_maturity(
  p_cve_id TEXT,
  p_maturity exploit_maturity,
  p_source TEXT,
  p_details JSONB DEFAULT '{}'
) RETURNS void AS $$
BEGIN
  UPDATE vulnerabilities
  SET
    exploit_maturity = GREATEST(exploit_maturity, p_maturity),
    exploit_maturity_source = CASE
      WHEN exploit_maturity < p_maturity THEN p_source
      ELSE exploit_maturity_source
    END,
    exploit_maturity_updated_at = NOW(),
    exploit_details = exploit_details || p_details,
    updated_at = NOW()
  WHERE cve_id = p_cve_id;
END;
$$ LANGUAGE plpgsql;

-- Update existing vulnerabilities with has_exploit to have at least 'functional' maturity
-- (only if has_exploit column exists)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'vulnerabilities' AND column_name = 'has_exploit') THEN
    UPDATE vulnerabilities
    SET
      exploit_maturity = 'functional',
      exploit_maturity_source = 'has_exploit_flag',
      exploit_maturity_updated_at = NOW()
    WHERE has_exploit = true
      AND (exploit_maturity IS NULL OR exploit_maturity = 'not_defined');
  END IF;
END $$;

-- Update KEV vulnerabilities to have at least 'high' maturity (actively exploited)
UPDATE vulnerabilities
SET
  exploit_maturity = 'high',
  exploit_maturity_source = 'cisa_kev',
  exploit_maturity_updated_at = NOW()
WHERE kev_date IS NOT NULL
  AND (exploit_maturity IS NULL OR exploit_maturity IN ('not_defined', 'unproven', 'poc', 'functional'));

-- Update priority calculation to include exploit maturity
-- Add to priority_factors when recalculating
CREATE OR REPLACE FUNCTION calculate_vuln_priority_with_maturity(
  p_cve_id TEXT
) RETURNS TABLE(score INTEGER, level TEXT, factors JSONB) AS $$
DECLARE
  v_vuln RECORD;
  v_score INTEGER := 0;
  v_factors JSONB := '[]'::JSONB;
  v_maturity_score INTEGER;
BEGIN
  SELECT * INTO v_vuln FROM vulnerabilities WHERE cve_id = p_cve_id;

  IF NOT FOUND THEN
    RETURN QUERY SELECT 0, 'unknown'::TEXT, '[]'::JSONB;
    RETURN;
  END IF;

  -- EPSS score (0-35 points)
  IF v_vuln.epss_score IS NOT NULL THEN
    v_score := v_score + LEAST(ROUND(v_vuln.epss_score * 35), 35);
    v_factors := v_factors || jsonb_build_object('factor', 'epss', 'value', v_vuln.epss_score, 'points', LEAST(ROUND(v_vuln.epss_score * 35), 35));
  END IF;

  -- CVSS score (0-20 points)
  IF v_vuln.cvss_score IS NOT NULL THEN
    v_score := v_score + ROUND(v_vuln.cvss_score * 2);
    v_factors := v_factors || jsonb_build_object('factor', 'cvss', 'value', v_vuln.cvss_score, 'points', ROUND(v_vuln.cvss_score * 2));
  END IF;

  -- KEV status (20 points)
  IF v_vuln.kev_date IS NOT NULL THEN
    v_score := v_score + 20;
    v_factors := v_factors || jsonb_build_object('factor', 'kev', 'value', true, 'points', 20);
  END IF;

  -- Exploit maturity (0-25 points) - NEW
  v_maturity_score := CASE v_vuln.exploit_maturity
    WHEN 'weaponized' THEN 25
    WHEN 'high' THEN 20
    WHEN 'functional' THEN 15
    WHEN 'poc' THEN 10
    WHEN 'unproven' THEN 5
    ELSE 0
  END;
  IF v_maturity_score > 0 THEN
    v_score := v_score + v_maturity_score;
    v_factors := v_factors || jsonb_build_object('factor', 'exploit_maturity', 'value', v_vuln.exploit_maturity, 'points', v_maturity_score);
  END IF;

  -- Cap at 100
  v_score := LEAST(v_score, 100);

  RETURN QUERY SELECT
    v_score,
    CASE
      WHEN v_score >= 70 THEN 'critical'
      WHEN v_score >= 50 THEN 'high'
      WHEN v_score >= 30 THEN 'medium'
      WHEN v_score >= 15 THEN 'low'
      ELSE 'info'
    END,
    v_factors;
END;
$$ LANGUAGE plpgsql;
