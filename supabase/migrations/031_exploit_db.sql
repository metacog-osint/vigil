-- Migration: Add Exploit-DB correlation fields
-- Date: January 15, 2026
-- Purpose: Track exploit availability for CVEs

BEGIN;

-- Add exploit availability fields to vulnerabilities table
ALTER TABLE vulnerabilities
ADD COLUMN IF NOT EXISTS exploit_count INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS exploit_types TEXT[] DEFAULT '{}',
ADD COLUMN IF NOT EXISTS exploit_platforms TEXT[] DEFAULT '{}',
ADD COLUMN IF NOT EXISTS has_public_exploit BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS exploit_sources TEXT[] DEFAULT '{}',
ADD COLUMN IF NOT EXISTS exploit_maturity VARCHAR(20) DEFAULT NULL;

-- Add index for exploit filtering
CREATE INDEX IF NOT EXISTS idx_vulns_has_exploit
ON vulnerabilities(has_public_exploit)
WHERE has_public_exploit = TRUE;

-- Create exploits table for detailed tracking
CREATE TABLE IF NOT EXISTS exploits (
  id SERIAL PRIMARY KEY,
  exploit_db_id INTEGER UNIQUE,
  cve_id TEXT REFERENCES vulnerabilities(cve_id) ON DELETE SET NULL,
  title TEXT NOT NULL,
  description TEXT,
  exploit_type VARCHAR(50),  -- remote, local, webapps, dos, shellcode
  platform VARCHAR(50),      -- linux, windows, multiple, etc.
  port INTEGER,
  author TEXT,
  published_date DATE,
  verified BOOLEAN DEFAULT FALSE,
  source VARCHAR(50) DEFAULT 'exploit-db',
  source_url TEXT,
  file_path TEXT,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for exploits table
CREATE INDEX IF NOT EXISTS idx_exploits_cve ON exploits(cve_id);
CREATE INDEX IF NOT EXISTS idx_exploits_type ON exploits(exploit_type);
CREATE INDEX IF NOT EXISTS idx_exploits_platform ON exploits(platform);
CREATE INDEX IF NOT EXISTS idx_exploits_date ON exploits(published_date DESC);

-- Function to update vulnerability exploit stats
CREATE OR REPLACE FUNCTION update_vuln_exploit_stats(p_cve_id TEXT)
RETURNS VOID AS $$
DECLARE
  v_count INTEGER;
  v_types TEXT[];
  v_platforms TEXT[];
  v_sources TEXT[];
BEGIN
  -- Aggregate exploit stats for the CVE
  SELECT
    COUNT(*)::INTEGER,
    ARRAY_AGG(DISTINCT exploit_type) FILTER (WHERE exploit_type IS NOT NULL),
    ARRAY_AGG(DISTINCT platform) FILTER (WHERE platform IS NOT NULL),
    ARRAY_AGG(DISTINCT source) FILTER (WHERE source IS NOT NULL)
  INTO v_count, v_types, v_platforms, v_sources
  FROM exploits
  WHERE cve_id = p_cve_id;

  -- Update the vulnerability record
  UPDATE vulnerabilities
  SET
    exploit_count = COALESCE(v_count, 0),
    exploit_types = COALESCE(v_types, '{}'),
    exploit_platforms = COALESCE(v_platforms, '{}'),
    has_public_exploit = (COALESCE(v_count, 0) > 0),
    exploit_sources = COALESCE(v_sources, '{}'),
    updated_at = NOW()
  WHERE cve_id = p_cve_id;
END;
$$ LANGUAGE plpgsql;

-- Trigger to update vulnerability stats when exploits change
CREATE OR REPLACE FUNCTION trigger_update_vuln_exploit_stats()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    IF OLD.cve_id IS NOT NULL THEN
      PERFORM update_vuln_exploit_stats(OLD.cve_id);
    END IF;
    RETURN OLD;
  ELSE
    IF NEW.cve_id IS NOT NULL THEN
      PERFORM update_vuln_exploit_stats(NEW.cve_id);
    END IF;
    RETURN NEW;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_exploit_vuln_stats
  AFTER INSERT OR UPDATE OR DELETE ON exploits
  FOR EACH ROW EXECUTE FUNCTION trigger_update_vuln_exploit_stats();

-- Add updated_at trigger
CREATE TRIGGER trigger_exploits_updated_at
  BEFORE UPDATE ON exploits
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

COMMIT;
