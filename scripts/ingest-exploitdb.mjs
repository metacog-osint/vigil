// Exploit-DB Ingestion Script
// Correlates CVEs with publicly available exploits
// Source: https://gitlab.com/exploit-database/exploitdb
// Run: node scripts/ingest-exploitdb.mjs

import { createClient } from '@supabase/supabase-js'
import https from 'https'
import { supabaseUrl, supabaseKey } from './env.mjs'

if (!supabaseUrl || !supabaseKey) {
  console.error('Missing Supabase credentials. Check your .env file.')
  process.exit(1)
}

const supabase = createClient(supabaseUrl, supabaseKey)

// Exploit-DB CSV from GitLab mirror
const EXPLOITDB_CSV_URL = 'https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv'

// Exploit type mapping
const EXPLOIT_TYPES = {
  'dos': 'dos',
  'local': 'local',
  'remote': 'remote',
  'webapps': 'webapps',
  'shellcode': 'shellcode',
  'papers': 'papers'
}

function fetchCSV(url) {
  return new Promise((resolve, reject) => {
    https.get(url, {
      headers: {
        'User-Agent': 'Vigil-CTI/1.0 (Threat Intelligence Platform)'
      }
    }, (res) => {
      if (res.statusCode === 301 || res.statusCode === 302) {
        return fetchCSV(res.headers.location).then(resolve).catch(reject)
      }
      if (res.statusCode !== 200) {
        reject(new Error(`HTTP ${res.statusCode}`))
        return
      }
      let data = ''
      res.on('data', chunk => data += chunk)
      res.on('end', () => resolve(data))
    }).on('error', reject)
  })
}

function parseCSV(csvText) {
  const lines = csvText.split('\n')
  const headers = lines[0].split(',').map(h => h.trim().toLowerCase())
  const records = []

  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim()
    if (!line) continue

    // Handle CSV with quoted fields
    const values = parseCSVLine(line)
    if (values.length < headers.length) continue

    const record = {}
    headers.forEach((header, idx) => {
      record[header] = values[idx]?.trim() || null
    })
    records.push(record)
  }

  return records
}

function parseCSVLine(line) {
  const values = []
  let current = ''
  let inQuotes = false

  for (let i = 0; i < line.length; i++) {
    const char = line[i]
    const nextChar = line[i + 1]

    if (char === '"' && !inQuotes) {
      inQuotes = true
    } else if (char === '"' && inQuotes) {
      if (nextChar === '"') {
        current += '"'
        i++ // Skip escaped quote
      } else {
        inQuotes = false
      }
    } else if (char === ',' && !inQuotes) {
      values.push(current)
      current = ''
    } else {
      current += char
    }
  }
  values.push(current)
  return values
}

function extractCVEs(text) {
  if (!text) return []
  const cvePattern = /CVE-\d{4}-\d{4,}/gi
  const matches = text.match(cvePattern) || []
  return [...new Set(matches.map(cve => cve.toUpperCase()))]
}

function normalizeExploitType(type) {
  if (!type) return 'unknown'
  const normalized = type.toLowerCase().trim()
  return EXPLOIT_TYPES[normalized] || 'unknown'
}

function normalizePlatform(platform) {
  if (!platform) return 'unknown'
  const p = platform.toLowerCase().trim()

  // Normalize common platforms
  if (p.includes('linux')) return 'linux'
  if (p.includes('windows')) return 'windows'
  if (p.includes('unix')) return 'unix'
  if (p.includes('osx') || p.includes('macos') || p.includes('mac os')) return 'macos'
  if (p.includes('android')) return 'android'
  if (p.includes('ios')) return 'ios'
  if (p.includes('multiple')) return 'multiple'
  if (p.includes('hardware')) return 'hardware'
  if (p.includes('php') || p.includes('asp') || p.includes('cgi')) return 'webapps'

  return p.length > 30 ? 'other' : p
}

async function getExistingCVEs() {
  // Get all CVE IDs we have in the vulnerabilities table
  const { data, error } = await supabase
    .from('vulnerabilities')
    .select('cve_id')

  if (error) {
    console.error('Error fetching CVEs:', error.message)
    return new Set()
  }

  return new Set((data || []).map(v => v.cve_id))
}

async function ingestExploitDB() {
  console.log('=== Exploit-DB Ingestion ===')
  console.log('Downloading exploit database CSV...\n')

  let csvData
  try {
    csvData = await fetchCSV(EXPLOITDB_CSV_URL)
    console.log(`Downloaded ${(csvData.length / 1024 / 1024).toFixed(2)} MB of data`)
  } catch (err) {
    console.error('Failed to download Exploit-DB CSV:', err.message)
    process.exit(1)
  }

  const records = parseCSV(csvData)
  console.log(`Parsed ${records.length} exploit records`)

  // Get existing CVEs to correlate
  const existingCVEs = await getExistingCVEs()
  console.log(`Found ${existingCVEs.size} CVEs in database to correlate\n`)

  let processed = 0
  let withCVE = 0
  let matched = 0
  let failed = 0

  const BATCH_SIZE = 100
  const exploitBatches = []
  let currentBatch = []

  for (const record of records) {
    processed++

    // Extract CVE references from title/description
    const cves = extractCVEs(record.description || record.title || '')
    if (cves.length === 0) continue

    withCVE++

    // Create exploit records for each CVE
    for (const cveId of cves) {
      const exploitRecord = {
        exploit_db_id: parseInt(record.id, 10) || null,
        cve_id: existingCVEs.has(cveId) ? cveId : null,
        title: (record.description || record.title || '').slice(0, 500),
        description: record.description?.slice(0, 2000) || null,
        exploit_type: normalizeExploitType(record.type),
        platform: normalizePlatform(record.platform),
        port: record.port ? parseInt(record.port, 10) : null,
        author: record.author?.slice(0, 100) || null,
        published_date: record.date || null,
        verified: record.verified === '1' || record.verified === 'true',
        source: 'exploit-db',
        source_url: record.id ? `https://www.exploit-db.com/exploits/${record.id}` : null,
        file_path: record.file || null,
        metadata: {
          original_id: record.id,
          all_cves: cves
        }
      }

      if (existingCVEs.has(cveId)) {
        matched++
      }

      currentBatch.push(exploitRecord)

      if (currentBatch.length >= BATCH_SIZE) {
        exploitBatches.push(currentBatch)
        currentBatch = []
      }
    }

    // Progress indicator
    if (processed % 5000 === 0) {
      console.log(`  Processed ${processed}/${records.length} records...`)
    }
  }

  // Don't forget the last batch
  if (currentBatch.length > 0) {
    exploitBatches.push(currentBatch)
  }

  console.log(`\nFound ${withCVE} exploits with CVE references`)
  console.log(`Matched ${matched} to existing CVEs in database`)
  console.log(`Upserting ${exploitBatches.length} batches...\n`)

  let upserted = 0
  for (let i = 0; i < exploitBatches.length; i++) {
    const batch = exploitBatches[i]

    const { error } = await supabase
      .from('exploits')
      .upsert(batch, {
        onConflict: 'exploit_db_id',
        ignoreDuplicates: false
      })

    if (error) {
      failed += batch.length
      if (failed <= 3) {
        console.error(`  Batch ${i + 1} error: ${error.message}`)
      }
    } else {
      upserted += batch.length
    }

    // Progress indicator
    if ((i + 1) % 10 === 0 || i === exploitBatches.length - 1) {
      console.log(`  Completed batch ${i + 1}/${exploitBatches.length}`)
    }
  }

  // Update vulnerability stats for matched CVEs
  console.log('\nUpdating vulnerability exploit statistics...')
  const matchedCVEs = [...existingCVEs].filter(cve => {
    return exploitBatches.flat().some(e => e.cve_id === cve)
  })

  let statsUpdated = 0
  for (const cveId of matchedCVEs) {
    const { error } = await supabase.rpc('update_vuln_exploit_stats', { p_cve_id: cveId })
    if (!error) statsUpdated++
  }

  console.log(`  Updated stats for ${statsUpdated} CVEs`)

  // Log sync
  await supabase.from('sync_log').insert({
    source: 'exploit-db',
    status: 'success',
    completed_at: new Date().toISOString(),
    records_processed: processed,
    records_added: upserted,
    metadata: {
      total_exploits: records.length,
      with_cve: withCVE,
      matched_cves: matched,
      failed: failed
    }
  })

  console.log('\n=== Summary ===')
  console.log(`Total Exploits Processed: ${processed}`)
  console.log(`Exploits with CVE refs: ${withCVE}`)
  console.log(`Matched to existing CVEs: ${matched}`)
  console.log(`Records Upserted: ${upserted}`)
  console.log(`Failed: ${failed}`)

  return { processed, withCVE, matched, upserted, failed }
}

ingestExploitDB().catch(console.error)
