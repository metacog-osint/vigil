// MalwareBazaar Enhanced Ingestion
// Fetches recent malware samples with extended metadata
// Run: node scripts/ingest-malwarebazaar.mjs

import { createClient } from '@supabase/supabase-js'
import https from 'https'
import { supabaseUrl, supabaseKey } from './env.mjs'

const MALWAREBAZAAR_API = 'https://mb-api.abuse.ch/api/v1/'

if (!supabaseUrl || !supabaseKey) {
  console.error('Missing Supabase credentials. Check your .env file.')
  process.exit(1)
}

const supabase = createClient(supabaseUrl, supabaseKey)

function postRequest(url, data) {
  return new Promise((resolve, reject) => {
    const postData = new URLSearchParams(data).toString()

    const options = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Content-Length': Buffer.byteLength(postData),
      },
    }

    const req = https.request(url, options, (res) => {
      let body = ''
      res.on('data', chunk => body += chunk)
      res.on('end', () => {
        try {
          resolve(JSON.parse(body))
        } catch (e) {
          reject(e)
        }
      })
    })

    req.on('error', reject)
    req.write(postData)
    req.end()
  })
}

function mapSignatureToFamily(signature) {
  if (!signature) return null

  const sig = signature.toLowerCase()

  // Map common signatures to families
  if (sig.includes('emotet')) return 'Emotet'
  if (sig.includes('trickbot')) return 'TrickBot'
  if (sig.includes('qakbot') || sig.includes('qbot')) return 'QakBot'
  if (sig.includes('icedid')) return 'IcedID'
  if (sig.includes('dridex')) return 'Dridex'
  if (sig.includes('cobalt') || sig.includes('beacon')) return 'Cobalt Strike'
  if (sig.includes('formbook')) return 'FormBook'
  if (sig.includes('agent tesla')) return 'Agent Tesla'
  if (sig.includes('remcos')) return 'Remcos'
  if (sig.includes('asyncrat')) return 'AsyncRAT'
  if (sig.includes('redline')) return 'RedLine'
  if (sig.includes('vidar')) return 'Vidar'
  if (sig.includes('raccoon')) return 'Raccoon'
  if (sig.includes('lockbit')) return 'LockBit'
  if (sig.includes('blackcat') || sig.includes('alphv')) return 'BlackCat'
  if (sig.includes('conti')) return 'Conti'
  if (sig.includes('ryuk')) return 'Ryuk'

  return signature
}

async function fetchRecentSamples(limit = 100) {
  console.log(`Fetching ${limit} recent samples...`)

  const response = await postRequest(MALWAREBAZAAR_API, {
    query: 'get_recent',
    selector: limit.toString(),
  })

  if (response.query_status !== 'ok') {
    throw new Error(`API error: ${response.query_status}`)
  }

  return response.data || []
}

async function fetchBySignature(signature, limit = 50) {
  console.log(`Fetching samples for signature: ${signature}...`)

  const response = await postRequest(MALWAREBAZAAR_API, {
    query: 'get_siginfo',
    signature: signature,
    limit: limit.toString(),
  })

  if (response.query_status !== 'ok' && response.query_status !== 'no_results') {
    console.warn(`Signature query warning: ${response.query_status}`)
  }

  return response.data || []
}

async function ingestMalwareBazaar() {
  console.log('Starting MalwareBazaar Enhanced Ingestion...')

  let allSamples = []

  // Fetch recent samples
  try {
    const recent = await fetchRecentSamples(200)
    console.log(`  Recent: ${recent.length} samples`)
    allSamples = allSamples.concat(recent)
  } catch (e) {
    console.error('Error fetching recent samples:', e.message)
  }

  // Fetch samples for high-priority malware families
  const priorityFamilies = [
    'Emotet', 'QakBot', 'IcedID', 'Cobalt Strike',
    'AsyncRAT', 'RedLine', 'LockBit', 'BlackCat'
  ]

  for (const family of priorityFamilies) {
    try {
      const samples = await fetchBySignature(family, 20)
      if (samples.length > 0) {
        console.log(`  ${family}: ${samples.length} samples`)
        allSamples = allSamples.concat(samples)
      }
      // Rate limiting
      await new Promise(r => setTimeout(r, 500))
    } catch (e) {
      console.error(`Error fetching ${family}:`, e.message)
    }
  }

  // Deduplicate by SHA256
  const seen = new Set()
  const uniqueSamples = allSamples.filter(s => {
    if (seen.has(s.sha256_hash)) return false
    seen.add(s.sha256_hash)
    return true
  })

  console.log(`\nTotal unique samples: ${uniqueSamples.length}`)

  let added = 0
  let failed = 0

  for (const sample of uniqueSamples) {
    try {
      // Insert malware sample record
      const sampleRecord = {
        sha256: sample.sha256_hash,
        sha1: sample.sha1_hash,
        md5: sample.md5_hash,
        filename: sample.file_name,
        file_type: sample.file_type_mime || sample.file_type,
        file_size: sample.file_size,
        signature: mapSignatureToFamily(sample.signature),
        tags: sample.tags || [],
        first_seen: sample.first_seen,
        last_seen: sample.last_seen || sample.first_seen,
        source: 'malwarebazaar',
        reporter: sample.reporter,
        delivery_method: sample.delivery_method,
        metadata: {
          origin_country: sample.origin_country,
          intelligence: sample.intelligence,
          comment: sample.comment,
          imphash: sample.imphash,
          ssdeep: sample.ssdeep,
          tlsh: sample.tlsh,
        }
      }

      const { error: sampleError } = await supabase
        .from('malware_samples')
        .upsert(sampleRecord, { onConflict: 'sha256' })

      if (sampleError) {
        failed++
        if (failed < 5) console.error(`Sample error:`, sampleError.message)
        continue
      }

      // Also add hash IOCs
      const hashIOCs = [
        { value: sample.sha256_hash, type: 'sha256' },
        { value: sample.sha1_hash, type: 'sha1' },
        { value: sample.md5_hash, type: 'md5' },
      ].filter(h => h.value)

      for (const hash of hashIOCs) {
        await supabase.from('iocs').upsert({
          value: hash.value,
          type: hash.type,
          source: 'malwarebazaar',
          confidence: 90,
          tags: ['malware', sample.signature].filter(Boolean),
          first_seen: sample.first_seen,
          last_seen: sample.last_seen || sample.first_seen,
          metadata: {
            filename: sample.file_name,
            signature: sample.signature,
          }
        }, { onConflict: 'value', ignoreDuplicates: false })
      }

      added++
    } catch (e) {
      failed++
    }
  }

  console.log(`\nMalwareBazaar Ingestion Complete:`)
  console.log(`  Added/Updated: ${added}`)
  console.log(`  Failed: ${failed}`)

  // Log sync
  await supabase.from('sync_log').insert({
    source: 'malwarebazaar',
    status: 'success',
    completed_at: new Date().toISOString(),
    records_processed: uniqueSamples.length,
    records_added: added,
  })

  return { added, failed }
}

ingestMalwareBazaar().catch(console.error)
